//-------- js/Skeleton.js --------
// Generated by CoffeeScript 1.12.2
(function () {
    var Bone, FourCC, RQ, Skeleton, console, cwaenv, document, log, setTimeout;
    cwaenv = this.getCWAEnv();
    console = this.console;
    document = this.document;
    setTimeout = this.setTimeout;
    log = console.log.bind(console);
    FourCC = cwaenv.get("FourCC");
    RQ = cwaenv.get("RotQuat");
    Bone = cwaenv.get("Bone");
    Skeleton = (function () {
        function Skeleton(usetrx, cputrx2mat) {
            this.root = null;
            this.bones = null;
            this.boneIndicesBy4CC = null;
            this.skinMatRows = null;
            this.boneSkinMatRows = null;
            this.USE_TRX_BONE_DATA = usetrx;
            this.TEST_CPU_TRX_TO_MAT = cputrx2mat;
            this.skelTexWidth = 0;
            this.skelTexHeight = 0;
            this.skelXformsData = null;
            this.twistData = null;
            this.ntdchk = 0;
            this.nchk = 0;
        }
        Skeleton.SHOULDER_TWIST_FLAG_VALUE = 2;
        Skeleton.WRIST_TWIST_FLAG_VALUE = 3;
        Skeleton.ROOT4cc = FourCC.fourCCInt("ROOT");
        Skeleton.create = function (jsnskel, usetrx, cputrx2mat) {
            var skeleton;
            skeleton = new Skeleton(usetrx, cputrx2mat);
            skeleton.setFromJSON(jsnskel);
            return skeleton;
        };
        Skeleton.fromBin = function (avdv, usetrx, cputrx2mat) {
            var skeleton;
            skeleton = new Skeleton(usetrx, cputrx2mat);
            skeleton.setFromBin(avdv);
            return skeleton;
        };
        Skeleton.prototype.setFromJSON = function (jsnbones) {
            return this.buildSkeleton(jsnbones.length, (function (b) {
                return Bone.fromJSON(jsnbones[b]);
            }));
        };
        Skeleton.prototype.setFromBin = function (avdv) {
            return this.buildSkeleton(avdv.nextUint(), (function () {
                return Bone.fromBin(avdv);
            }));
        };
        Skeleton.prototype.buildSkeleton = function (nbones, nextBoneFun) {
            var b, bone, k, ref;
            this.bones = new Array(nbones);
            this.boneIndicesBy4CC = [];
            for (b = k = 0, ref = nbones; 0 <= ref ? k < ref : k > ref; b = 0 <= ref ? ++k : --k) {
                this.bones[b] = bone = nextBoneFun(b);
                this.setExtraDataForBone(b, bone);
            }
            this.createTwistData();
            return this.generateBindPoseData();
        };
        Skeleton.prototype.setExtraDataForBone = function (b, bone) {
            var b4cc, p4cc, parentBone;
            b4cc = bone.get4CC();
            if (b4cc === Skeleton.ROOT4cc) {
                this.root = bone;
            }
            this.boneIndicesBy4CC[b4cc] = b;
            p4cc = bone.getParent4CC();
            if (p4cc) {
                parentBone = this.getBoneBy4CC(p4cc);
                bone.setParent(parentBone);
                return parentBone.addChild(bone);
            }
        };
        Skeleton.prototype.calcTexSize = function (elFloats, elRows) {
            var texHeight, texWidth;
            texWidth = 1;
            while (texWidth < elFloats) {
                texWidth *= 2;
            }
            if (elFloats !== texWidth) {
                log("calTexSize: WARNING: Element size " + elFloats + " for data as texture needs to be power of two");
            }
            texWidth = Math.max(4, texWidth);
            texHeight = 1;
            while (texWidth * texHeight < elRows * elFloats) {
                texHeight *= 2;
            }
            return [texWidth * texHeight, texWidth / 4, texHeight];
        };
        Skeleton.prototype.createTwistData = function () {
            var NB, SKEL, b, b4, bTwData, bone, flags, i, k, len, p4cc, parentID, ref, ref1, results, rotW, rotX, vecSize;
            NB = this.bones.length;
            SKEL = Skeleton;
            ref = this.calcTexSize(4, NB), vecSize = ref[0], this.twistTexWidth = ref[1], this.twistTexHeight = ref[2];
            this.twistData = new Float32Array(vecSize);
            ref1 = this.bones;
            results = [];
            for (b = k = 0, len = ref1.length; k < len; b = ++k) {
                bone = ref1[b];
                b4 = 4 * b;
                flags = 1;
                if (bone.doesShoulderTwist()) {
                    flags *= SKEL.SHOULDER_TWIST_FLAG_VALUE;
                }
                if (bone.doesWristTwist()) {
                    flags *= SKEL.WRIST_TWIST_FLAG_VALUE;
                }
                p4cc = bone.getParent4CC();
                parentID = p4cc === 0 ? -1 : this.boneIndicesBy4CC[p4cc];
                rotX = rotW = -1;
                bTwData = [rotX, rotW, parentID, flags];
                results.push((function () {
                    var l, results1;
                    results1 = [];
                    for (i = l = 0; l < 4; i = ++l) {
                        results1.push(this.twistData[b4 + i] = bTwData[i]);
                    }
                    return results1;
                }).call(this));
            }
            return results;
        };
        Skeleton.prototype.updateTwistData = function () {
            var b, b4, bone, iirxRQ, k, len, ref, tbone, twistRQ;
            twistRQ = RQ.create();
            iirxRQ = RQ.create();
            ref = this.bones;
            for (b = k = 0, len = ref.length; k < len; b = ++k) {
                bone = ref[b];
                b4 = 4 * b;
                if (this.twistData[b4 + 3] !== 1) {
                    tbone = bone;
                    if (bone.doesWristTwist()) {
                        tbone = bone.getChild(0);
                    }
                    iirxRQ.setVec(tbone.getInvInitRotX());
                    twistRQ.setVec(tbone.getLocalRot());
                    twistRQ.setExtractRotX();
                    twistRQ.setPostMultiply(iirxRQ);
                    if (bone.doesShoulderTwist()) {
                        twistRQ.setInvertX();
                    }
                    this.twistData[b4 + 0] = twistRQ.xyzw[0];
                    this.twistData[b4 + 1] = twistRQ.xyzw[3];
                }
            }
            if (this.ntdchk < 10) {
                /*
                log "____  skel twist data #{@ntdchk}"
                for bone,b in @bones
                bStr = do bone.idStr
                [tda, tdb, tdc, tdd] = (@twistData[b*4+i] for i in [0...4])
                if @ntdchk is 0 or tdc is 39
                tdas = RQ.fStr tda, 3;  tdbs = RQ.fStr tdb, 3
                tdcs = ""+Math.floor tdc;    tdds = ""+Math.floor tdd
                log "#{bStr}: #{tdas} #{tdbs} #{tdcs} #{tdds}"
                */
            }
            return ++this.ntdchk;
        };
        Skeleton.prototype.generateBindPoseData = function () {
            var NB, bone, k, len, ref, ref1, vecSize;
            this.root.computeGlobalTransforms();
            ref = this.bones;
            for (k = 0, len = ref.length; k < len; k++) {
                bone = ref[k];
                bone.generateBindPoseData();
            }
            if (this.USE_TRX_BONE_DATA) {
                NB = this.bones.length;
                ref1 = this.calcTexSize(16, NB), vecSize = ref1[0], this.skelTexWidth = ref1[1], this.skelTexHeight = ref1[2];
                this.skelXformsData = new Float32Array(vecSize);
                if (this.TEST_CPU_TRX_TO_MAT) {
                    this.skinMatRows = new Float32Array(this.bones.length * 3 * 4);
                    this.boneSkinMatRows = new Float32Array(3 * 4);
                    this.vsSkinMatRows = new Array(this.bones.length * 3 * 4);
                }
                this.setInvBindPoseTRXData();
                this.updateCurGlobalPoseTRXData();
                this.updateTwistData();
            } else {
                this.skinMatRows = new Float32Array(this.bones.length * 3 * 4);
                this.boneSkinMatRows = new Float32Array(3 * 4);
                this.updateSkinMatRows();
            }
            return void 0;
        };
        Skeleton.prototype.setInvBindPoseTRXData = function () {
            var boneIBPFun;
            boneIBPFun = function (bone) {
                return bone.getInvBindPoseTRX();
            };
            return this._setTRXDataBuffers(0, boneIBPFun);
        };
        Skeleton.prototype.updateCurGlobalPoseTRXData = function () {
            var boneCGPFun;
            boneCGPFun = function (bone) {
                return bone.getGlobalTRX();
            };
            this._setTRXDataBuffers(2 * 4, boneCGPFun);
            if (this.TEST_CPU_TRX_TO_MAT) {
                this.updateSkinMatRows();
                return this.updateVSSkinMatRows();
            }
        };
        Skeleton.prototype._setTRXDataBuffers = function (offset, btrxfun) {
            var b, bone, br, brot, bt, btrans, btrx, i, k, l, len, ref, results;
            ref = this.bones;
            results = [];
            for (b = k = 0, len = ref.length; k < len; b = ++k) {
                bone = ref[b];
                bt = b * 4 * 4 + offset;
                br = bt + 4;
                btrx = btrxfun(bone);
                btrans = (btrx.trans()).xyz;
                brot = (btrx.rot()).xyzw;
                for (i = l = 0; l < 3; i = ++l) {
                    this.skelXformsData[bt + i] = btrans[i];
                }
                results.push((function () {
                    var m, results1;
                    results1 = [];
                    for (i = m = 0; m < 4; i = ++m) {
                        results1.push(this.skelXformsData[br + i] = brot[i]);
                    }
                    return results1;
                }).call(this));
            }
            return results;
        };
        void 0;
        Skeleton.prototype.updateSkinMatRows = function () {
            var b, b12, bSMR, bone, i, k, l, len, len1, ref, ref1, s, sMR;
            sMR = this.skinMatRows;
            bSMR = this.boneSkinMatRows;
            b12 = 0;
            ref = this.bones;
            for (b = k = 0, len = ref.length; k < len; b = ++k) {
                bone = ref[b];
                ref1 = bone.generateSkinMatRows(bSMR);
                for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
                    s = ref1[i];
                    sMR[b12 + i] = s;
                }
                b12 += 3 * 4;
            }
            return void 0;
        };
        Skeleton.prototype.getBones = function () {
            return this.bones;
        };
        Skeleton.prototype.getBonesCount = function () {
            if (this.bones) {
                return this.bones.length;
            } else {
                return 0;
            }
        };
        Skeleton.prototype.getBoneBy4CC = function (fourcc) {
            return this.bones[this.boneIndicesBy4CC[fourcc]];
        };
        Skeleton.prototype.getBone = function (b) {
            return this.bones[b];
        };
        Skeleton.prototype.getBoneIndex = function (fourcc) {
            return this.boneIndicesBy4CC[fourcc];
        };
        Skeleton.prototype.setBones = function (trsets) {
            var bone, k, len, trset;
            for (k = 0, len = trsets.length; k < len; k++) {
                trset = trsets[k];
                bone = this.getBoneBy4CC(trset.getFourCC());
                if (bone) {
                    if (bone.isRoot()) {
                        bone.updateLocalTransAndRot(trset);
                    } else {
                        bone.updateLocalRot(trset);
                    }
                }
            }
            this.root.computeGlobalTransforms();
            if (this.USE_TRX_BONE_DATA) {
                this.updateCurGlobalPoseTRXData();
                return this.updateTwistData();
            } else {
                return this.updateSkinMatRows();
            }
        };
        Skeleton.prototype.getSkinMatRows = function () {
            return this.skinMatRows;
        };
        Skeleton.prototype.getSkelXformsData = function () {
            return this.skelXformsData;
        };
        Skeleton.prototype.getSkelTexWidth = function () {
            return this.skelTexWidth;
        };
        Skeleton.prototype.getSkelTexHeight = function () {
            return this.skelTexHeight;
        };
        Skeleton.prototype.getBoneTwistData = function () {
            return this.twistData;
        };
        Skeleton.prototype.getTwistTexWidth = function () {
            return this.twistTexWidth;
        };
        Skeleton.prototype.getTwistTexHeight = function () {
            return this.twistTexHeight;
        };
        Skeleton.prototype.getVSSkinMatRows = function () {
            return this.vsSkinMatRows;
        };
        Skeleton.prototype.updateVSSkinMatRows = function () {
            var b, b12, bone, i, i4, j, k, l, len, m, ref, vsbsmr;
            vsbsmr = [
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ];
            ref = this.bones;
            for (b = k = 0, len = ref.length; k < len; b = ++k) {
                bone = ref[b];
                b12 = b * 3 * 4;
                this._vsSetSkinMatRowsForBone(vsbsmr, b);
                for (i = l = 0; l < 3; i = ++l) {
                    i4 = i * 4;
                    for (j = m = 0; m < 4; j = ++m) {
                        this.vsSkinMatRows[b12 + i4 + j] = vsbsmr[i][j];
                    }
                }
            }
            return this.checkSkinningTRXs();
        };
        Skeleton.prototype.checkSkinningTRXs = function () {
            var b, b12, bok, i, k, l, nmatch, ref, rowstr, smrb, vssmrb;
            if (this.nchk === 0) {
                rowstr = (function (_this) {
                    return function (mat, b, i) {
                        var base, j, row;
                        base = (b * 3 + i) * 4;
                        row = (function () {
                            var k, results;
                            results = [];
                            for (j = k = 0; k < 4; j = ++k) {
                                results.push(mat[base + j]);
                            }
                            return results;
                        })();
                        return RQ.qStr(row, 3);
                    };
                })(this);
                nmatch = 0;
                for (b = k = 0, ref = this.bones.length; 0 <= ref ? k < ref : k > ref; b = 0 <= ref ? ++k : --k) {
                    b12 = b * 3 * 4;
                    smrb = (function () {
                        var l, results;
                        results = [];
                        for (i = l = 0; l < 12; i = ++l) {
                            results.push(this.skinMatRows[b12 + i]);
                        }
                        return results;
                    }).call(this);
                    vssmrb = (function () {
                        var l, results;
                        results = [];
                        for (i = l = 0; l < 12; i = ++l) {
                            results.push(this.vsSkinMatRows[b12 + i]);
                        }
                        return results;
                    }).call(this);
                    bok = true;
                    for (i = l = 0; l <= 12; i = ++l) {
                        if (1e-4 <= Math.abs(smrb[i] - vssmrb[i])) {
                            bok = false;
                        }
                    }
                    if (!bok) {
                        log("skin mats match FAILS for bone " + b);
                    }
                    if (bok) {
                        ++nmatch;
                    }
                }
                log("matching skin mat count: " + nmatch + " / " + this.bones.length);
                return ++this.nchk;
            }
        };
        Skeleton.prototype._setQProd = function (qr, qa, qb) {
            var i, k, rc, rd, re, va, vb, wa, wb;
            va = [qa[0], qa[1], qa[2]];
            vb = [qb[0], qb[1], qb[2]];
            wa = qa[3];
            wb = qb[3];
            qr[3] = (wa * wb) - (va[0] * vb[0] + va[1] * vb[1] + va[2] * vb[2]);
            rc = [wa * vb[0], wa * vb[1], wa * vb[2]];
            rd = [wb * va[0], wb * va[1], wb * va[2]];
            re = [va[1] * vb[2] - va[2] * vb[1], va[2] * vb[0] - va[0] * vb[2], va[0] * vb[1] - va[1] * vb[0]];
            for (i = k = 0; k < 3; i = ++k) {
                qr[i] = rc[i] + rd[i] + re[i];
            }
            return void 0;
        };
        Skeleton.prototype._setRotate = function (tr, t, q) {
            var i, k, qc, qq, qr, qt;
            qc = [-q[0], -q[1], -q[2], q[3]];
            qt = [t[0], t[1], t[2], 0];
            qq = [0, 0, 0, 0];
            qr = [0, 0, 0, 0];
            this._setQProd(qq, qt, qc);
            this._setQProd(qr, q, qq);
            for (i = k = 0; k < 3; i = ++k) {
                tr[i] = qr[i];
            }
            return void 0;
        };
        Skeleton.prototype._setTRXProd = function (tr, rr, ta, ra, tb, rb) {
            var i, k, tba;
            tba = [0, 0, 0];
            this._setRotate(tba, tb, ra);
            for (i = k = 0; k < 3; i = ++k) {
                tr[i] = ta[i] + tba[i];
            }
            this._setQProd(rr, ra, rb);
            return void 0;
        };
        Skeleton.prototype._setTRMatRows = function (smr, t, r) {
            var ref, ref1, ref2, w, wx2, wy2, wz2, x, x2, xx2, xy2, xz2, y, y2, yy2, yz2, z, z2, zz2;
            x = r[0];
            y = r[1];
            z = r[2];
            w = r[3];
            x2 = x + x;
            y2 = y + y;
            z2 = z + z;
            wx2 = w * x2;
            wy2 = w * y2;
            wz2 = w * z2;
            xx2 = x * x2;
            xy2 = x * y2;
            xz2 = x * z2;
            yy2 = y * y2;
            yz2 = y * z2;
            zz2 = z * z2;
            [].splice.apply(smr[0], [0, 4].concat(ref = [1.0 - yy2 - zz2, xy2 - wz2, xz2 + wy2, t[0]])), ref;
            [].splice.apply(smr[1], [0, 4].concat(ref1 = [xy2 + wz2, 1.0 - xx2 - zz2, yz2 - wx2, t[1]])), ref1;
            return ([].splice.apply(smr[2], [0, 4].concat(ref2 = [xz2 - wy2, yz2 + wx2, 1.0 - xx2 - yy2, t[2]])), ref2);
        };
        Skeleton.prototype._vsSetSkinMatRowsForBone = function (bsmr, b) {
            var i, icgr, icgt, iibr, iibt, rCGb, rIBb, rSkinb, tCGb, tIBb, tSkinb;
            iibt = b * 4 * 4;
            iibr = iibt + 4;
            icgt = iibr + 4;
            icgr = icgt + 4;
            tSkinb = [0, 0, 0];
            rSkinb = [0, 0, 0, 0];
            tCGb = (function () {
                var k, results;
                results = [];
                for (i = k = 0; k < 3; i = ++k) {
                    results.push(this.skelXforms[icgt + i]);
                }
                return results;
            }).call(this);
            rCGb = (function () {
                var k, results;
                results = [];
                for (i = k = 0; k < 4; i = ++k) {
                    results.push(this.skelXforms[icgr + i]);
                }
                return results;
            }).call(this);
            tIBb = (function () {
                var k, results;
                results = [];
                for (i = k = 0; k < 3; i = ++k) {
                    results.push(this.skelXforms[iibt + i]);
                }
                return results;
            }).call(this);
            rIBb = (function () {
                var k, results;
                results = [];
                for (i = k = 0; k < 4; i = ++k) {
                    results.push(this.skelXforms[iibr + i]);
                }
                return results;
            }).call(this);
            this._setTRXProd(tSkinb, rSkinb, tCGb, rCGb, tIBb, rIBb);
            return this._setTRMatRows(bsmr, tSkinb, rSkinb);
        };
        return Skeleton;
    })();
    cwaenv.add(Skeleton, "Skeleton");
}).call(this);