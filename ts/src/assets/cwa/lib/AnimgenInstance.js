//-------- js/AnimgenInstance.js --------
// Generated by CoffeeScript 1.12.2
(function () {
    var AGI, AvCache, Config, Data, HtoG, console, cwaenv, document, log, theConfig;
    cwaenv = this.getCWAEnv();
    Data = cwaenv.get("Data");
    AvCache = cwaenv.get("AvCache");
    Config = cwaenv.get("Config");
    HtoG = cwaenv.get("HtoG");
    console = this.console;
    document = this.document;
    theConfig = Config != null ? Config.theConfig : void 0;
    log = console.log;
    AGI = (function () {
        AGI.animInit = Module.cwrap('animgenInit', ['number'], []);
        AGI.animAlloc = Module.cwrap('animgenAllocate', ['number'], ['number', 'string', 'number', 'number']);
        AGI.animSetOutput = Module.cwrap('animgenSetOutput', ['number'], ['number', 'string']);
        AGI.animSetAvatar = Module.cwrap('animgenSetAvatar', ['number'], ['number', 'string', 'string', 'string', 'string', 'string']);
        AGI.animSetSequence = Module.cwrap('animgenSetSequence', ['number'], ['number', 'number']);
        AGI.animGenerateFrames = Module.cwrap('animgenGenerateFrames', ['number'], ['number', 'string']);
        AGI.animDeAlloc = Module.cwrap('animgenDeAllocate', ['number'], ['number']);
        AGI.animTerm = Module.cwrap('animgenTerminate', ['number'], []);
        AGI.MAX = 1;
        AGI.STATE = {
            Unset: 0,
            Alloc: 1,
            AvatarSet: 2,
            SeqReady: 3,
            SeqInProgress: 4,
            Terminated: 5
        };
        AGI.CB = {
            Unset: 0,
            Sign: 1,
            Skip: 2,
            Done: 3,
            Fail: 4
        };
        AGI.initialised = AGI.STATE.Unset;
        AGI.instances = [];
        AGI.H2G = null;
        AGI.Valid = function (id) {
            return id >= 0 && id < AGI.MAX;
        };
        AGI.Get = function (id) {
            return AGI.instances[id] || null;
        };
        AGI.Init = function () {
            if (AGI.initialised !== AGI.STATE.Unset) {
                console.warn("Animgen already initialised");
                return false;
            } else if (AGI.animInit()) {
                Module.CB_SeqStart = function (jagid, status, nframes) {
                    return (AGI.Get(jagid)).SeqStart(status, nframes);
                };
                Module.CB_SignStart = function (jagid, gloss, signIx, frameIx) {
                    return (AGI.Get(jagid)).SignStart(gloss, signIx, frameIx);
                };
                Module.CB_SeqEnd = (function (_this) {
                    return function (jagid) {
                        return (AGI.Get(jagid)).SeqEnd();
                    };
                })(this);
                Module.CB_FrameStart = (function (_this) {
                    return function (jagid, nmorphs, nbones, time, duration) {
                        return (AGI.Get(jagid)).FrameStart(nmorphs, nbones, time, duration);
                    };
                })(this);
                Module.CB_Morph = function (jagid, morph) {
                    return (AGI.Get(jagid)).Morph(morph);
                };
                Module.CB_Bone = function (jagid, bone) {
                    return (AGI.Get(jagid)).Bone(bone);
                };
                AGI.initialised = AGI.STATE.Alloc;
                return true;
            } else {
                console.warn("Animgen failed to initialise");
                return false;
            }
        };
        AGI.Terminate = function () {
            if (AGI.initialised !== AGI.STATE.Alloc) {
                console.warn("Animgen not initialised");
                return false;
            } else {
                AGI.initialised = AGI.STATE.Unset;
                if (AGI.animTerm()) {
                    return true;
                } else {
                    console.warn("Animgen failed to terminate");
                    return false;
                }
            }
        };
        AGI.Alloc = function (errPath, errAppend, errNoErr) {
            var id, newAGI;
            if (errPath == null) {
                errPath = null;
            }
            if (errAppend == null) {
                errAppend = false;
            }
            if (errNoErr == null) {
                errNoErr = true;
            }
            if (AGI.initialised !== AGI.STATE.Alloc) {
                AGI.Init();
            }
            newAGI = null;
            id = 0;
            while (id < AGI.MAX && (AGI.Get(id)) !== null) {
                id++;
            }
            if (id < AGI.MAX) {
                if (AGI.animAlloc(id, errPath, errAppend, errNoErr)) {
                    newAGI = AGI.instances[id] = new AGI(id);
                } else {
                    console.warn("Animgen failed to allocate instance " + id);
                }
            } else {
                console.warn("Animgen instances all allocated");
            }
            return newAGI;
        };

        function AGI(jagid1) {
            this.jagid = jagid1;
            this.state = AGI.STATE.Alloc;
            this.doneProm = null;
            this.doneResolve = null;
            this.avatar = null;
            this.guiPanel = null;
            this.fps = 25;
            this.sigmlSigns = null;
            this.totFrames = 0;
            this.currSigns = null;
            this.currFrames = this.currGloss = this.currSignIx = this.currFrameIx = null;
            this.frameMorphs = this.frameBones = this.frameTime = this.frameDur = null;
            if (theConfig != null) {
                if (AGI.H2G == null) {
                    AGI.H2G = new HtoG(Data.absoluteURI("h2s.xsl", theConfig.cwaBase), false, 0);
                }
            }
        }
        AGI.prototype.SetAvatar = function (newAv, avXMLs, gui) {
            if (this.state === AGI.STATE.Alloc) {
                console.log("Animgen SetAvatar " + newAv + " for instance " + this.jagid + " (" + this.state + ") gui " + gui);
                if (AGI.animSetAvatar(this.jagid, newAv, avXMLs[1], avXMLs[0], avXMLs[2], avXMLs[3])) {
                    this.avatar = newAv;
                    this.guiPanel = gui;
                    this.state = AGI.STATE.AvatarSet;
                    return true;
                } else {
                    console.warn("Animgen failed to SetAvatar " + newAv + " for instance " + this.jagid);
                    return false;
                }
            } else {
                console.warn("Animgen wrong state to SetAvatar " + newAv + " for instance " + this.jagid + " (" + this.state + ")");
                return false;
            }
        };
        AGI.prototype.SetSequence = function (fps) {
            if (this.state === AGI.STATE.AvatarSet || this.state === AGI.STATE.SeqReady) {
                if (AGI.animSetSequence(this.jagid, fps)) {
                    this.fps = fps;
                    this.state = AGI.STATE.SeqReady;
                    return true;
                } else {
                    console.warn("Animgen failed to SetSequence " + fps + " for instance " + this.jagid);
                    return false;
                }
            } else {
                console.warn("Animgen wrong state to SetSequence " + fps + " for instance " + this.jagid + " (" + this.state + ")");
                return false;
            }
        };
        AGI.prototype.EndSequence = function () {
            if (this.state === AGI.STATE.AvatarSet || this.state === AGI.STATE.SeqReady) {
                console.log("Animgen EndSequence for instance " + this.jagid + " (" + this.state + ")");
                this.state = AGI.STATE.AvatarSet;
                if (typeof this.doneResolve === "function") {
                    this.doneResolve(null);
                }
                return true;
            } else {
                console.warn("Animgen wrong state to EndSequence for instance " + this.jagid + " (" + this.state + ")");
                return false;
            }
        };
        AGI.prototype.GenerateFrames = function (sigml, casCB) {
            var theSigns;
            this.casCB = casCB;
            if (this.state === AGI.STATE.SeqReady) {
                this.state = AGI.STATE.SeqInProgress;
              // console.log(AGI.animGenerateFrames(this.jagid, sigml));
               console.log("***********************************************");

                 if (!AGI.animGenerateFrames(this.jagid, sigml)) {
                     console.warn("Animgen failed to GenerateFrames for instance " + this.jagid);
                 }
                this.state = AGI.STATE.SeqReady;
                theSigns = this.currSigns;
                this.currSigns = null;
                return theSigns;
            } else {
                console.warn("Animgen wrong state to GenerateFrames for instance " + this.jagid + " (" + this.state + ")");
                return null;
            }
        };
        AGI.prototype.DeAlloc = function () {
            if (this.state === AGI.STATE.AvatarSet) {
                this.state = AGI.STATE.Terminated;
                AGI.instances[this.jagid] = null;
                if (AGI.animDeAlloc(this.jagid)) {
                    return true;
                } else {
                    console.warn("Animgen could not DeAlloc instance " + this.jagid);
                    return false;
                }
            } else {
                console.log("Animgen wrong state to DeAlloc for instance " + this.jagid + " (" + this.state + ")");
                return false;
            }
        };
        AGI.prototype.SeqStart = function (status, nframes) {
            this.totFrames = nframes;
            return this.currSigns = [];
        };
        AGI.prototype._endFrame = function () {
            var newFrame;
            if (this.frameBones) {
                newFrame = {
                    time: this.frameTime,
                    duration: this.frameDur,
                    morphs: this.frameMorphs,
                    bones: this.frameBones
                };
                this.currFrames.push(newFrame);
                return this.frameMorphs = this.frameBones = null;
            }
        };
        AGI.prototype.FrameStart = function (nmorphs, nbones, time, duration) {
            this._endFrame();
            this.frameTime = time;
            this.frameDur = duration;
            this.frameMorphs = [];
            return this.frameBones = [];
        };
        AGI.prototype.Morph = function (newMorph) {
            return this.frameMorphs.push(newMorph);
        };
        AGI.prototype.Bone = function (newBone) {
            return this.frameBones.push(newBone);
        };
        AGI.prototype._endSign = function () {
            var newSign;
            if (this.currFrames) {
                this._endFrame();
                newSign = {
                    type: AGI.CB.Sign,
                    signIndex: this.currSignIx,
                    gloss: this.currGloss,
                    baseFrameIndex: this.currFrameIx,
                    frames: this.currFrames
                };
                if (this.casCB) {
                    this.casCB(newSign);
                } else {
                    this.currSigns.push(newSign);
                }
                return this.currFrames = this.currGloss = null;
            }
        };
        AGI.prototype.SignStart = function (gloss, signIx, frameIx) {
            this._endSign();
            this.currGloss = gloss;
            this.currSignIx = signIx;
            this.currFrameIx = frameIx;
            return this.currFrames = [];
        };
        AGI.prototype.SeqEnd = function () {
            return this._endSign();
        };
        AGI.PrepInstance = function (av, gui, fps) {
            return new Promise((function (_this) {
                return function (resolve, reject) {
                    var makeNewAGI, theAGI, waitAGIDone;
                    theAGI = AGI.Get(0);
                    if ((theAGI != null ? theAGI.avatar : void 0) === av && (theAGI != null ? theAGI.guiPanel : void 0) === gui) {
                        return resolve(theAGI);
                    } else {
                        console.log("PrepInstance finds " + (theAGI != null ? theAGI.avatar : void 0) + "/" + (theAGI != null ? theAGI.guiPanel : void 0) + " but needs new " + av + "/" + gui);
                        makeNewAGI = function () {
                            var avC, cmC, newAGI, ref;
                            if ((ref = AGI.Get(0)) != null) {
                                ref.DeAlloc();
                            }
                            newAGI = AGI.Alloc();
                            cmC = AvCache.get("COMMON");
                            avC = AvCache.get(av);
                            return Promise.all([cmC.getZIPEnt("config"), avC.getZIPEnt("config"), avC.getZIPEnt("asd"), avC.getZIPEnt("nonManuals")])["catch"](function (err) {
                                console.warn(err);
                                throw err;
                            }).then(function (XMLs) {
                                newAGI.SetAvatar(av, XMLs, gui);
                                return resolve(newAGI);
                            });
                        };
                        waitAGIDone = function () {
                            theAGI = AGI.Get(0);
                            if ((theAGI != null) && theAGI.state !== AGI.STATE.AvatarSet) {
                                if (theAGI.doneProm == null) {
                                    theAGI.doneProm = new Promise(function (resolveDone, rejectDone) {
                                        return theAGI.doneResolve = resolveDone;
                                    });
                                }
                                return theAGI.doneProm.then(function () {
                                    return waitAGIDone();
                                });
                            } else {
                                return makeNewAGI();
                            }
                        };
                        return waitAGIDone();
                    }
                };
            })(this));
        };
        AGI.SiGMLToCAS = function (sigml, av, gui, fps, CB) {
            (AGI.PrepInstance(av, gui, fps)).then((function (_this) {
                return function (theAGI) {
                    var gloss, i, len, nd, nn, okSigns, procSigns, ref, ref1, sigDoc;
                    console.log("SiGMLToCAS " + theAGI.jagid + " call SetSequence " + av + "/" + gui + " fps " + fps);
                    _this.sigmlSigns = [];
                    sigDoc = Data.toDOM(sigml, function (err, msg) {
                        return console.log("SiGML malformed: " + err);
                    });
                    ref = (sigDoc != null ? sigDoc.documentElement.childNodes : void 0) || [];
                    for (i = 0, len = ref.length; i < len; i++) {
                        nd = ref[i];
                        nn = nd != null ? nd.nodeName : void 0;
                        if (nn === "hamgestural_sign" || nn === "hns_sign") {
                            gloss = (ref1 = nd.attributes.getNamedItem("gloss")) != null ? ref1.value : void 0;
                            console.log("SiGML XML has: " + gloss);
                            _this.sigmlSigns.push({
                                type: nn,
                                gloss: gloss,
                                sigml: "<sigml>" + (Data.mnDOM(nd)) + "</sigml>"
                            });
                        }
                    }
                    if (_this.sigmlSigns.length === 0) {
                        console.log("No signs");
                        CB({
                            type: AGI.CB.Fail,
                            err: "SiGML invalid"
                        });
                    } else {
                        theAGI.SetSequence(fps);
                        okSigns = 0;
                        procSigns = function () {
                            var h2gCB, sign;
                            if (_this.sigmlSigns.length === 0) {
                                if (okSigns > 0) {
                                    theAGI.EndSequence();
                                    return CB({
                                        type: AGI.CB.Done
                                    });
                                } else {
                                    return CB({
                                        type: AGI.CB.Fail,
                                        err: "SiGML invalid"
                                    });
                                }
                            } else {
                                sign = _this.sigmlSigns.shift();
                                if (sign.type === "hns_sign") {
                                    h2gCB = function (res) {
                                        if (res.errCount > 0 || !res.sigDoc) {
                                            console.warn("HtoG Errors:\n" + res.errText);
                                            CB({
                                                type: AGI.CB.Skip,
                                                err: "SiGML invalid HNS sign"
                                            });
                                        } else if (theAGI.GenerateFrames(Data.mnDOM(res.sigDoc), CB)) {
                                            okSigns++;
                                        } else {
                                            CB({
                                                type: AGI.CB.Skip,
                                                err: "SiGML invalid sign"
                                            });
                                        }
                                        return setTimeout(procSigns, 5);
                                    };
                                    var temp=AGI.H2G.parseHtoGText(sign.sigml, h2gCB);
                                    console.log(temp);
                                    return temp;

                                } else {
                                    if (theAGI.GenerateFrames(sign.sigml, CB)) {
                                        okSigns++;
                                    }
                                    return setTimeout(procSigns, 5);
                                }
                            }
                        };
                        procSigns();
                    }
                    return void 0;
                };
            })(this));
            return void 0;
        };
        return AGI;
    })();
    cwaenv.add(AGI, "AGI");
}).call(this);