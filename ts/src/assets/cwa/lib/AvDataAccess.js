// {{POST_RUN_ADDITIONS}}
// {{MODULE_ADDITIONS}}
//-------- js/AvDataAccess.js --------
// Generated by CoffeeScript 1.12.2
(function () {
    var AvDataAccess, Config, console, cwaenv, document, log, setTimeout, zip;
    cwaenv = this.getCWAEnv();
    Config = cwaenv.get("Config");
    console = this.console;
    document = this.document;
    setTimeout = this.setTimeout;
    zip = this.zip;
    log = console.log.bind(console);
    AvDataAccess = (function () {
        function AvDataAccess(avName, avDefHandler1) {
            this.avName = avName;
            this.avDefHandler = avDefHandler1;
            this.avURL = "" + (Config.getAvBase(this.avName)) + this.avName + ".jar";
            this.avDataView = false;
            this.avItemsReady = false;
            this.XMLs = null;
            this.scanZIPProm = null;
            this.initAvItemData();
            this.AsynchAvJARScan();
        }
        AvDataAccess.STD_JARP_ITEM_TAG_MAP = {
            "asd.xml": "asd",
            "avatardef.jarp": "avDef",
            "avatardef.arp": "avDef",
            "config.xml": "config",
            "nonmanuals.xml": "nonManuals"
        };
        AvDataAccess.STD_JARP_TAG = "avDef";
        AvDataAccess.IS_PNG = function (ename) {
            return /.+\.png$/.test(ename);
        };
        AvDataAccess.prototype.initAvItemData = function () {
            var aitmap, aittag, ename, ref, tag;
            aitmap = {};
            aittag = [];
            ref = AvDataAccess.STD_JARP_ITEM_TAG_MAP;
            for (ename in ref) {
                tag = ref[ename];
                aitmap[ename] = tag;
                if ((aittag.indexOf(tag)) === -1) {
                    aittag.push(tag);
                }
            }
            this.avItemTagMap = aitmap;
            this.avItemTags = aittag;
            this.entries = {};
            this.pngEntries = {};
            return void 0;
        };
        /*
        zip.js
        ------
        Readers:
        zip.TextReader( txt )
        zip.BlobReader( blob )
        zip.Data64URIReader( dataURI )
        zip.HttpReader( url )
        zip.HttpRangeReader( url )
        Writers:
        zip.TextWriter()
        zip.BlobWriter()
        zip.FileWriter( fileEntry )
        zip.Data64URIWriter( [mimeString] )
        * Added to the standard repertoire:
        zip.DataViewWriter( bytelength )
        */
        AvDataAccess.prototype._checksumdv = function (dv, prev) {
            var c, i, j, ref;
            if (prev == null) {
                prev = 0;
            }
            c = prev;
            for (i = j = 0, ref = dv.byteLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                c = (((((c >>> 1) + ((c & 1) << 15)) | 0) + ((dv.getUint8(i)) & 0xff)) & 0xffff) | 0;
            }
            return c;
        };
        AvDataAccess.prototype.startZIPScan = function (zURL, entryFun, doneFun) {
            var entriesFun, errorFun;
            entriesFun = function (entries) {
                var N, entry, i;
                N = entries.length;
                for (i in entries) {
                    entry = entries[i];
                    entryFun(i, entry);
                }
                return doneFun(N);
            };
            errorFun = function (error) {
                log("Read error for " + zURL + ": " + error);
                return doneFun();
            };
            return zip.createReader(new zip.HttpReader(zURL), (function (zrdr) {
                return zrdr.getEntries(entriesFun);
            }), errorFun);
        };
        AvDataAccess.prototype.AsynchAvJARScan = function () {
            var N_ap, avPfx, jarURL;
            jarURL = this.avURL;
            avPfx = this.avName + "/";
            N_ap = avPfx.length;
            log((((new Date).toISOString()).substr(11, 12)) + " AsynchAvJARScan() started url=" + jarURL);
            return this.scanZIPProm = new Promise((function (_this) {
                return function (resolve, reject) {
                    var doneAllHandler, entryHandler;
                    entryHandler = function (i, entry) {
                        var aitag, efname, ename, szc, szu;
                        efname = entry.filename;
                        if ((efname.substring(0, N_ap)) === avPfx) {
                            ename = efname.substring(N_ap);
                            aitag = _this.avItemTagMap[ename];
                            if (aitag) {
                                _this.entries[aitag] = entry;
                            } else if (AvDataAccess.IS_PNG(ename)) {
                                _this.pngEntries[ename] = entry;
                            }
                            szc = entry.compressedSize;
                            return szu = entry.uncompressedSize;
                        }
                    };
                    doneAllHandler = function (N) {
                        log((((new Date).toISOString()).substr(11, 12)) + " AsynchAvJARScan() ended url=" + jarURL + " entries=" + N);
                        _this.avItemsReady = true;
                        if (N) {
                            if (_this.XMLs == null) {
                                _this.XMLs = {};
                            }
                            return resolve();
                        } else {
                            return reject(new Error("Scan of JAR " + jarURL + " failed"));
                        }
                    };
                    return _this.startZIPScan(jarURL, entryHandler, doneAllHandler);
                };
            })(this));
        };
        AvDataAccess.prototype.extractAvDefEntry = function (ent) {
            var base, theEntry;
            theEntry = this.entries[ent];
            if ((base = this.XMLs)[ent] == null) {
                base[ent] = new Promise((function (_this) {
                    return function (resolve, reject) {
                        var DVWriter, cb, tag;
                        tag = ent;
                        cb = function (content) {
                            if (tag === AvDataAccess.STD_JARP_TAG) {} else {}
                            return resolve(content);
                        };
                        if (theEntry != null) {
                            if (tag === AvDataAccess.STD_JARP_TAG) {
                                DVWriter = new zip.DataViewWriter(theEntry.uncompressedSize);
                            } else {
                                DVWriter = new zip.TextWriter("UTF-8");
                            }
                            theEntry.getData(DVWriter, cb);
                        } else {
                            reject(new Error("No " + tag + " for " + _this.avName));
                        }
                        return void 0;
                    };
                })(this));
            }
            return this.XMLs[ent];
        };
        AvDataAccess.prototype.procAvDef = function (dv, avDefHandler) {
            this.avDataView = dv;
            return typeof avDefHandler === "function" ? avDefHandler(this.avName, this.avDataView, this.getPNGURIGenerator()) : void 0;
        };
        AvDataAccess.prototype.getPNGURIGenerator = function () {
            return (function (_this) {
                return function (pngName) {
                    var pngEntry;
                    pngEntry = _this.pngEntries[pngName];
                    return function (pngHandler) {
                        if (pngEntry) {
                            pngEntry.getData(new zip.Data64URIWriter("image/png"), (function (pngURI) {
                                return pngHandler(pngURI);
                            }));
                        } else {
                            setTimeout((function () {
                                return pngHandler(null);
                            }), 0);
                        }
                        return void 0;
                    };
                };
            })(this);
        };
        return AvDataAccess;
    })();
    cwaenv.add(AvDataAccess, "AvDataAccess");
}).call(this);