//-------- js/HtoG.js --------
// Generated by CoffeeScript 1.12.2
(function () {
    var Data, HMLBuilder, HNSSign, Ham4Parser, HamLexer, HtoG, Node, XSLT, cwaenv, logLev;
    cwaenv = this.getCWAEnv();
    Data = cwaenv.get("Data");
    Node = cwaenv.get("Node");
    HNSSign = cwaenv.get("HNSSign");
    HamLexer = cwaenv.get("HamLexer");
    Ham4Parser = cwaenv.get("Ham4Parser");
    HMLBuilder = cwaenv.get("HMLBuilder");
    XSLT = cwaenv.get("XSLT");
    logLev = 0;
    HtoG = (function () {
        function HtoG(XSLTURI, hmlLog, logLev1) {
            this.XSLTURI = XSLTURI;
            this.hmlLog = hmlLog != null ? hmlLog : false;
            this.logLev = logLev1 != null ? logLev1 : 0;
            this.XSLTProc = new XSLT(this.XSLTURI);
            this.trace("HtoG processor created for \"" + this.XSLTURI + "\"");
        }
        HtoG.prototype.treeString = function (el) {
            var i, j, n, ref, res;
            res = "";
            if (el) {
                res = "(" + el;
                n = el.getChildCount();
                for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
                    res += " " + this.treeString(el.getChild(i));
                }
                res += ")";
            }
            return res;
        };
        HtoG.prototype._sortAttrs = function (el) {
            var attList, attr, j, k, l, len, len1, len2, nd, newList, ref, results;
            if (el.hasChildNodes()) {
                ref = el.childNodes;
                for (j = 0, len = ref.length; j < len; j++) {
                    nd = ref[j];
                    if (nd.nodeType === Node.ELEMENT_NODE || nd.nodeType === Node.DOCUMENT_NODE) {
                        this._sortAttrs(nd);
                    }
                }
            }
            if (el.nodeType === Node.ELEMENT_NODE && el.hasAttributes() && el.attributes.length > 1) {
                attList = (function () {
                    var k, len1, ref1, results;
                    ref1 = el.attributes;
                    results = [];
                    for (k = 0, len1 = ref1.length; k < len1; k++) {
                        attr = ref1[k];
                        results.push(attr);
                    }
                    return results;
                })();
                newList = attList.sort(function (a, b) {
                    return a.name > b.name;
                });
                for (k = 0, len1 = attList.length; k < len1; k++) {
                    attr = attList[k];
                    el.removeAttribute(attr.name);
                }
                results = [];
                for (l = 0, len2 = newList.length; l < len2; l++) {
                    attr = newList[l];
                    results.push(el.setAttribute(attr.name, attr.value));
                }
                return results;
            }
        };
        HtoG.prototype.sortDocAttrs = function (doc) {
            this._sortAttrs(doc.documentElement);
            return doc;
        };
        HtoG.prototype._parseHSign = function (sigDoc) {
            var builder, errReport, hamString, hmlDoc, lexer, parser, root, sigtrans, sigtree, treewalker;
            this.trace("SiGML: " + sigDoc + " " + (Data.ppDOM(sigDoc)));
            hmlDoc = new HNSSign(sigDoc);
            hamString = hmlDoc.man();
            lexer = new HamLexer(hamString, Ham4Parser.tokenNames, 0);
            lexer.setLogLevel(this.logLev);
            parser = new Ham4Parser(lexer);
            parser.setLogLevel(this.logLev);
            root = (parser.hamsinglesign()).getTree();
            errReport = parser.checkErrors();
            if (errReport != null) {
                this.trace("Parse errors: " + errReport.errCount + ": " + errReport.errText);
                return errReport;
            } else {
                this.trace("After parsing: " + (this.treeString(root)));
                treewalker = new Ham4HMLGen(new org.antlr.runtime.tree.CommonTreeNodeStream(root));
                HMLBuilder.setLogLevel(this.logLev);
                builder = new HMLBuilder;
                try {
                    sigtree = treewalker.hamsignseq(builder);
                    builder.insertNonManual(sigtree.documentElement, hmlDoc.nonman());
                    builder.checkedSetAttr(sigtree.documentElement, "gloss", hmlDoc.gloss());
                    builder.checkedSetAttr(sigtree.documentElement, "duration", hmlDoc.duration());
                    builder.checkedSetAttr(sigtree.documentElement, "speed", hmlDoc.speed());
                    builder.checkedSetAttr(sigtree.documentElement, "timescale", hmlDoc.timeScale());
                    this.trace("After tree building:\n" + (Data.ppDOM(sigtree)));
                    if (this.hmlLog) {
                        console.warn("########  HML -- gloss: " + (hmlDoc.gloss()) + "  ########\n" + (Data.ppDOM(sigtree)) + "\n");
                    }
                    sigtrans = this.XSLTProc.applyXSLT(sigtree);
                    this.trace("After XSLT processing:\n" + (Data.ppDOM(sigtrans)));
                    return {
                        sigDoc: sigtrans
                    };
                } catch (error) {
                    this.trace("Failed tree building or XSLT transformation");
                    return {
                        errCount: 1,
                        errText: "Failed tree building or XSLT transformation"
                    };
                }
            }
        };
        HtoG.prototype._cleanSiGML = function (parent) {
            var cn, j, k, len, len1, nd, nds, ref;
            nds = [];
            ref = parent.childNodes;
            for (j = 0, len = ref.length; j < len; j++) {
                cn = ref[j];
                if (cn != null) {
                    nds.push(cn);
                }
            }
            for (k = 0, len1 = nds.length; k < len1; k++) {
                nd = nds[k];
                switch (nd.nodeType) {
                    case Node.COMMENT_NODE:
                    case Node.TEXT_NODE:
                        parent.removeChild(nd);
                        break;
                    default:
                        if (nd.childNodes != null) {
                            this._cleanSiGML(nd);
                        }
                }
            }
            return parent;
        };
        HtoG.prototype._parseSiGML = function (sigDoc) {
            var errCount, errText, gloss, j, len, nd, nom, parseRes, ref, ref1, ref2, signIx, typ;
            errCount = 0;
            errText = "";
            signIx = 0;
            if (sigDoc.documentElement != null) {
                this._cleanSiGML(sigDoc);
                ref = sigDoc.documentElement.childNodes;
                for (j = 0, len = ref.length; j < len; j++) {
                    nd = ref[j];
                    nom = nd != null ? nd.nodeName : void 0;
                    typ = nd != null ? nd.nodeType : void 0;
                    this.trace("SiGML Element: " + typ + " " + nom);
                    if (nom === "hns_sign") {
                        signIx + (gloss = (ref1 = nd.attributes.getNamedItem("gloss")) != null ? ref1.value : void 0);
                        this.trace("Sign " + signIx + ": " + nom + " gloss: " + gloss);
                        parseRes = this._parseHSign(nd);

                        if (parseRes != null ? parseRes.errText : void 0) {
                            errCount++;
                            errText += parseRes.errText + " [Sign: " + signIx + " Gloss: \"" + gloss + "\"]";
                            sigDoc.documentElement.removeChild(nd);
                        } else if (parseRes != null ? parseRes.sigDoc : void 0) {
                            sigDoc.documentElement.replaceChild(parseRes.sigDoc, nd);
                        }
                    } else if (nom === "hamgestural_sign") {
                        signIx++;
                        this.trace("Sign " + signIx + ": " + nom + " gloss: " + ((ref2 = nd.attributes.getNamedItem("gloss")) != null ? ref2.value : void 0));
                    }
                }
            } else {
                errCount++;
                errText += "Invalid SiGML file";
                sigDoc = null;
            }
            return {
                sigDoc: sigDoc,
                errCount: errCount,
                errText: errText
            };
        };
        HtoG.prototype.parseHtoGText = function (sigTxt, theCB) {
            var errCount, errText, errXML, gotXSLT, res, sigDoc;
            errCount = 0;
            errText = "";
            res = {};
            errXML = (function (_this) {
                return function (level, msg) {
                    errCount++;
                    return errText += "XML parse " + level + ": " + msg;
                };
            })(this);
            sigDoc = Data.toDOM("" + sigTxt, errXML);
            if (sigDoc != null) {
                res.sigDoc = sigDoc;
            }
            if (errCount > 0) {
                res.errCount = errCount;
                res.errText = errText;
                return theCB(res);
            } else {
                gotXSLT = (function (_this) {
                    return function () {
                        return theCB(_this._parseSiGML(res.sigDoc));
                    };
                })(this);
                return this.XSLTProc.syncXSLT(gotXSLT);
            }
        };
        HtoG.prototype.parseHtoGURI = function (sigURI, theCB) {
            var gotSiGML, res;
            res = {};
            gotSiGML = (function (_this) {
                return function (sigDoc, errCount, msg) {
                    if (errCount > 0) {
                        res.errCount = errCount;
                        res.errText = "SiGML fetch: " + msg;
                        if (sigDoc != null) {
                            res.sigDoc = sigDoc;
                        }
                        return theCB(res);
                    } else if (sigDoc != null) {
                        return _this.parseHtoGText(sigDoc, theCB);
                    } else {
                        res.errCount = 1;
                        res.errText = "No SiGML data found";
                        return theCB(res);
                    }
                };
            })(this);
            return Data.fetchText(sigURI, gotSiGML);
        };
        HtoG.prototype.setLogLevel = function (lev) {
            return this.logLev = lev;
        };
        HtoG.prototype.setHMLLog = function (flag) {
            return this.hmlLog = flag;
        };
        HtoG.prototype.trace = function (str) {
            if (this.logLev >= 440) {
                return console.log(str);
            }
        };
        return HtoG;
    })();
    cwaenv.add(HtoG, "HtoG");
}).call(this);