//-------- js/AvatarCamera.js --------
// Generated by CoffeeScript 1.12.2
(function () {
    var AvatarCamera, M4, RQ, V3, console, cwaenv, document, log, setTimeout,
        bind = function (fn, me) {
            return function () {
                return fn.apply(me, arguments);
            };
        };
    cwaenv = this.getCWAEnv();
    console = this.console;
    document = this.document;
    setTimeout = this.setTimeout;
    log = console.log.bind(console);
    V3 = cwaenv.get("E3Vec");
    RQ = cwaenv.get("RotQuat");
    M4 = cwaenv.get("Mat4");
    AvatarCamera = (function () {
        function AvatarCamera(gl, camdata, yadj, FROM_METRES) {
            this.gl = gl;
            this.FROM_METRES = FROM_METRES;
            this.touchmove = bind(this.touchmove, this);
            this.touchend = bind(this.touchend, this);
            this.touchstart = bind(this.touchstart, this);
            this.X_UNIT = V3.makeV3(1, 0, 0);
            this.Y_UNIT = V3.makeV3(0, 1, 0);
            this.viewMat = AvatarCamera.makeIdTRMat();
            this.projMat = AvatarCamera.makeIdTRMat();
            this.viewWidth = -1;
            this.viewHeight = -1;
            this.Z_NEAR = 0.05;
            this.Z_FAR = 500;
            this.FOV = camdata[5];
            this.qCamRot = AvatarCamera.createRotation(this.Y_UNIT, 0);
            this.orbitRadius = camdata[2];
            this.camTarget = V3.makeV3(camdata[0], camdata[1] + yadj, 0);
            this.initCamRots = [camdata[3], -camdata[4]];
            this.camEye = V3.make3Vec();
            this.camEyeR = V3.make3Vec();
            this.camTargetR = V3.make3Vec();
            this.dragMode = -1;
            this.shiftDown = false;
            this.ctrlDown = false;
            this.prevMouseXY = [0, 0];
            this.newMouseXY = [0, 0];
            this.prevTouchXY = [0, 0];
            this.newTouchXY = [0, 0];
            this.SCALE_TIME = 200;
            this.DRAG_SENSITIVITY = 0.7;
            this.DELTA_DIST_SCALE = 0.01;
        }
        AvatarCamera.DEGS_TO_RADS = RQ.DEGS_TO_RADS;
        AvatarCamera.createRotation = function (axis, angle) {
            return RQ.setAxisAngleQV(RQ.makeQV(0, 0, 0, 0), axis, angle);
        };
        AvatarCamera.makeIdTRMat = function () {
            var m;
            m = new Float32Array(16);
            m[0] = m[5] = m[10] = m[15] = 1;
            return m;
        };
        AvatarCamera.prototype.getViewMatrix = function () {
            return this.viewMat;
        };
        AvatarCamera.prototype.getProjMatrix = function () {
            return this.projMat;
        };
        AvatarCamera.prototype.update = function (dt, w, h) {
            var dts, dx, dxm, dy, dym;
            this.checkUpdateViewport(w, h);
            if (0 <= this.dragMode) {
                dts = this.SCALE_TIME * dt;
                dx = this.newMouseXY[0] - this.prevMouseXY[0] + this.newTouchXY[0] - this.prevTouchXY[0];
                dy = this.newMouseXY[1] - this.prevMouseXY[1] + this.newTouchXY[1] - this.prevTouchXY[1];
                dx = 0 < dx ? Math.min(dts, dx) : Math.max(-dts, dx);
                dy = 0 < dy ? Math.min(dts, dy) : Math.max(-dts, dy);
                dxm = dx * this.DRAG_SENSITIVITY;
                dym = dy * this.DRAG_SENSITIVITY;
                if (this.dragMode === 0) {
                    this.applyRotsOnVertAndHoriz(-dxm, 0);
                    this.orbitRadius -= dy * this.DELTA_DIST_SCALE;
                } else if (this.dragMode === 1) {
                    this.applyRotsOnVertAndHoriz(-dxm, -dym);
                } else if (this.dragMode === 2) {
                    V3.setAddV3(this.camTarget, [0, dy * this.DELTA_DIST_SCALE, 0]);
                }
                this.prevMouseXY = this.newMouseXY;
                this.prevTouchXY = this.newTouchXY;
                return this.updateViewMatrix();
            }
        };
        AvatarCamera.prototype.setShift = function (flag) {
            return this.shiftDown = Boolean(flag);
        };
        AvatarCamera.prototype.setCtrl = function (flag) {
            return this.ctrlDown = Boolean(flag);
        };
        AvatarCamera.prototype.mouseover = function (evt) {};
        AvatarCamera.prototype.mouseout = function (evt) {
            return this.mouseup();
        };
        AvatarCamera.prototype.mousedown = function (evt) {
            this.setShift(evt.shiftKey);
            this.setCtrl(evt.ctrlKey || evt.metaKey);
            this.dragMode = this.shiftDown ? 1 : this.ctrlDown ? 2 : 0;
            this.prevMouseXY = [evt.screenX, evt.screenY];
            return this.mousemove(evt);
        };
        AvatarCamera.prototype.mouseup = function () {
            return this.dragMode = -1;
        };
        AvatarCamera.prototype.mousemove = function (evt) {
            this.setShift(evt.shiftKey);
            this.setCtrl(evt.ctrlKey || evt.metaKey);
            if (0 <= this.dragMode) {
                return this.newMouseXY = [evt.screenX, evt.screenY];
            }
        };
        AvatarCamera.prototype.touchstart = function (evt) {
            this.dragMode = Math.min(evt.touches.length - 1, 2);
            this.prevTouchXY = [evt.touches[0].pageX, evt.touches[0].pageY];
            return this.touchmove(evt);
        };
        AvatarCamera.prototype.touchend = function (evt) {
            return this.dragMode = -1;
        };
        AvatarCamera.prototype.touchmove = function (evt) {
            evt.preventDefault();
            evt.stopPropagation();
            if (0 <= this.dragMode) {
                return this.newTouchXY = [evt.touches[0].pageX, evt.touches[0].pageY];
            }
        };
        AvatarCamera.prototype.zVecFromViewMat = function (zXYZ, m4) {
            return V3.setV3_xyz(zXYZ, m4[2], m4[6], m4[10]);
        };
        AvatarCamera.prototype.applyRotsOnVertAndHoriz = function (vdegs, hdegs) {
            var DEGS_TO_RADS, qrotH, qrotV;
            DEGS_TO_RADS = AvatarCamera.DEGS_TO_RADS;
            if (vdegs !== 0) {
                qrotV = AvatarCamera.createRotation(this.Y_UNIT, vdegs * DEGS_TO_RADS);
                RQ.setProductQV(this.qCamRot, qrotV, this.qCamRot);
            }
            if (hdegs !== 0) {
                qrotH = AvatarCamera.createRotation(this.X_UNIT, hdegs * DEGS_TO_RADS);
                RQ.setProductQV(this.qCamRot, this.qCamRot, qrotH);
            }
            return RQ.setRotMat4x4TransposeFromQV(this.viewMat, this.qCamRot);
        };
        AvatarCamera.prototype.checkUpdateViewport = function (w, h) {
            var crots;
            crots = this.initCamRots;
            if (crots) {
                this.applyRotsOnVertAndHoriz(crots[0], crots[1]);
                this.initCamRots = null;
                this.updateViewMatrix();
            }
            if (this.viewWidth !== w || this.viewHeight !== h) {
                this.viewWidth = w;
                this.viewHeight = h;
                return this.setProjMatrix();
            }
        };
        AvatarCamera.prototype.setProjMatrix = function () {
            var h, szFar, szNear, w;
            w = this.viewWidth;
            h = this.viewHeight;
            szNear = this.Z_NEAR * this.FROM_METRES;
            szFar = this.Z_FAR * this.FROM_METRES;
            return M4.setPerspective(this.projMat, this.FOV, w / h, szNear, szFar);
        };
        AvatarCamera.prototype.updateViewMatrix = function () {
            this.zVecFromViewMat(this.camEye, this.viewMat);
            V3.setScaleV3(this.camEye, this.orbitRadius);
            V3.setAddV3(this.camEye, this.camTarget);
            V3.setV3(this.camEyeR, this.camEye);
            V3.setV3(this.camTargetR, this.camTarget);
            V3.setScaleV3(this.camEyeR, this.FROM_METRES);
            V3.setScaleV3(this.camTargetR, this.FROM_METRES);
            return M4.setLookAt(this.viewMat, this.camEyeR, this.camTargetR, this.Y_UNIT);
        };
        return AvatarCamera;
    })();
    cwaenv.add(AvatarCamera, "AvatarCamera");
}).call(this);